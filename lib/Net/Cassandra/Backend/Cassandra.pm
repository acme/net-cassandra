#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Net::Cassandra::Backend::Thrift;

use Net::Cassandra::Backend::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Net::Cassandra::Backend::Cassandra_get_slice_by_names_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_slice_by_names_args->mk_accessors( qw( tablename key columnParent columnNames ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{tablename} = undef;
$self->{key} = undef;
$self->{columnParent} = undef;
$self->{columnNames} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columnParent}) {
      $self->{columnParent} = $vals->{columnParent};
    }
    if (defined $vals->{columnNames}) {
      $self->{columnNames} = $vals->{columnNames};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_slice_by_names_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{columnParent});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size55 = 0;
          $self->{columnNames} = [];
          my $_etype58 = 0;
          $xfer += $input->readListBegin(\$_etype58, \$_size55);
          for (my $_i59 = 0; $_i59 < $_size55; ++$_i59)
          {
            my $elem60 = undef;
            $xfer += $input->readString(\$elem60);
            push(@{$self->{columnNames}},$elem60);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_slice_by_names_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnParent}) {
    $xfer += $output->writeFieldBegin('columnParent', Net::Cassandra::Backend::TType::STRING, 3);
    $xfer += $output->writeString($self->{columnParent});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnNames}) {
    $xfer += $output->writeFieldBegin('columnNames', Net::Cassandra::Backend::TType::LIST, 4);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRING, scalar(@{$self->{columnNames}}));
      {
        foreach my $iter61 (@{$self->{columnNames}}) 
        {
          $xfer += $output->writeString($iter61);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_slice_by_names_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_slice_by_names_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ire} = undef;
$self->{nfe} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_slice_by_names_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size62 = 0;
          $self->{success} = [];
          my $_etype65 = 0;
          $xfer += $input->readListBegin(\$_etype65, \$_size62);
          for (my $_i66 = 0; $_i66 < $_size62; ++$_i66)
          {
            my $elem67 = undef;
            $elem67 = new Net::Cassandra::Backend::column_t();
            $xfer += $elem67->read($input);
            push(@{$self->{success}},$elem67);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{nfe} = new Net::Cassandra::Backend::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_slice_by_names_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::LIST, 0);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter68 (@{$self->{success}}) 
        {
          $xfer += ${iter68}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_slice_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_slice_args->mk_accessors( qw( tablename key columnParent start finish isAscending offset count ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{tablename} = undef;
$self->{key} = undef;
$self->{columnParent} = undef;
$self->{start} = undef;
$self->{finish} = undef;
$self->{isAscending} = undef;
$self->{offset} = undef;
$self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columnParent}) {
      $self->{columnParent} = $vals->{columnParent};
    }
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{finish}) {
      $self->{finish} = $vals->{finish};
    }
    if (defined $vals->{isAscending}) {
      $self->{isAscending} = $vals->{isAscending};
    }
    if (defined $vals->{offset}) {
      $self->{offset} = $vals->{offset};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_slice_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{columnParent});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{finish});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::BOOL) {
        $xfer += $input->readBool(\$self->{isAscending});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{offset});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_slice_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnParent}) {
    $xfer += $output->writeFieldBegin('columnParent', Net::Cassandra::Backend::TType::STRING, 3);
    $xfer += $output->writeString($self->{columnParent});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', Net::Cassandra::Backend::TType::STRING, 4);
    $xfer += $output->writeString($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{finish}) {
    $xfer += $output->writeFieldBegin('finish', Net::Cassandra::Backend::TType::STRING, 5);
    $xfer += $output->writeString($self->{finish});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{isAscending}) {
    $xfer += $output->writeFieldBegin('isAscending', Net::Cassandra::Backend::TType::BOOL, 6);
    $xfer += $output->writeBool($self->{isAscending});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{offset}) {
    $xfer += $output->writeFieldBegin('offset', Net::Cassandra::Backend::TType::I32, 7);
    $xfer += $output->writeI32($self->{offset});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', Net::Cassandra::Backend::TType::I32, 8);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_slice_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_slice_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ire} = undef;
$self->{nfe} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_slice_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size69 = 0;
          $self->{success} = [];
          my $_etype72 = 0;
          $xfer += $input->readListBegin(\$_etype72, \$_size69);
          for (my $_i73 = 0; $_i73 < $_size69; ++$_i73)
          {
            my $elem74 = undef;
            $elem74 = new Net::Cassandra::Backend::column_t();
            $xfer += $elem74->read($input);
            push(@{$self->{success}},$elem74);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{nfe} = new Net::Cassandra::Backend::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::LIST, 0);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter75 (@{$self->{success}}) 
        {
          $xfer += ${iter75}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_column_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_column_args->mk_accessors( qw( tablename key columnPath ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{tablename} = undef;
$self->{key} = undef;
$self->{columnPath} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columnPath}) {
      $self->{columnPath} = $vals->{columnPath};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_column_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{columnPath});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_column_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnPath}) {
    $xfer += $output->writeFieldBegin('columnPath', Net::Cassandra::Backend::TType::STRING, 3);
    $xfer += $output->writeString($self->{columnPath});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_column_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_column_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ire} = undef;
$self->{nfe} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_column_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{success} = new Net::Cassandra::Backend::column_t();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{nfe} = new Net::Cassandra::Backend::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_column_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_column_count_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_column_count_args->mk_accessors( qw( tablename key columnParent ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{tablename} = undef;
$self->{key} = undef;
$self->{columnParent} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columnParent}) {
      $self->{columnParent} = $vals->{columnParent};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_column_count_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{columnParent});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_column_count_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnParent}) {
    $xfer += $output->writeFieldBegin('columnParent', Net::Cassandra::Backend::TType::STRING, 3);
    $xfer += $output->writeString($self->{columnParent});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_column_count_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_column_count_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_column_count_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_column_count_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_insert_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_insert_args->mk_accessors( qw( tablename key columnPath cellData timestamp block_for ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{tablename} = undef;
$self->{key} = undef;
$self->{columnPath} = undef;
$self->{cellData} = undef;
$self->{timestamp} = undef;
$self->{block_for} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columnPath}) {
      $self->{columnPath} = $vals->{columnPath};
    }
    if (defined $vals->{cellData}) {
      $self->{cellData} = $vals->{cellData};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{block_for}) {
      $self->{block_for} = $vals->{block_for};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_insert_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{columnPath});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{cellData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{block_for});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_insert_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnPath}) {
    $xfer += $output->writeFieldBegin('columnPath', Net::Cassandra::Backend::TType::STRING, 3);
    $xfer += $output->writeString($self->{columnPath});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cellData}) {
    $xfer += $output->writeFieldBegin('cellData', Net::Cassandra::Backend::TType::STRING, 4);
    $xfer += $output->writeString($self->{cellData});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Net::Cassandra::Backend::TType::I64, 5);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{block_for}) {
    $xfer += $output->writeFieldBegin('block_for', Net::Cassandra::Backend::TType::I32, 6);
    $xfer += $output->writeI32($self->{block_for});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_insert_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_insert_result->mk_accessors( qw( ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{ire} = undef;
$self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_insert_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_insert_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_batch_insert_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_batch_insert_args->mk_accessors( qw( batchMutation block_for ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{batchMutation} = undef;
$self->{block_for} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{batchMutation}) {
      $self->{batchMutation} = $vals->{batchMutation};
    }
    if (defined $vals->{block_for}) {
      $self->{block_for} = $vals->{block_for};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_batch_insert_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{batchMutation} = new Net::Cassandra::Backend::batch_mutation_t();
        $xfer += $self->{batchMutation}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{block_for});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_batch_insert_args');
  if (defined $self->{batchMutation}) {
    $xfer += $output->writeFieldBegin('batchMutation', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{batchMutation}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{block_for}) {
    $xfer += $output->writeFieldBegin('block_for', Net::Cassandra::Backend::TType::I32, 2);
    $xfer += $output->writeI32($self->{block_for});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_batch_insert_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_batch_insert_result->mk_accessors( qw( ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{ire} = undef;
$self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_batch_insert_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_batch_insert_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_remove_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_remove_args->mk_accessors( qw( tablename key columnPathOrParent timestamp block_for ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{tablename} = undef;
$self->{key} = undef;
$self->{columnPathOrParent} = undef;
$self->{timestamp} = undef;
$self->{block_for} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columnPathOrParent}) {
      $self->{columnPathOrParent} = $vals->{columnPathOrParent};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{block_for}) {
      $self->{block_for} = $vals->{block_for};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_remove_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{columnPathOrParent});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{block_for});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_remove_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnPathOrParent}) {
    $xfer += $output->writeFieldBegin('columnPathOrParent', Net::Cassandra::Backend::TType::STRING, 3);
    $xfer += $output->writeString($self->{columnPathOrParent});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Net::Cassandra::Backend::TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{block_for}) {
    $xfer += $output->writeFieldBegin('block_for', Net::Cassandra::Backend::TType::I32, 5);
    $xfer += $output->writeI32($self->{block_for});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_remove_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_remove_result->mk_accessors( qw( ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{ire} = undef;
$self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_remove_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_remove_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_columns_since_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_columns_since_args->mk_accessors( qw( tablename key columnParent timeStamp ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{tablename} = undef;
$self->{key} = undef;
$self->{columnParent} = undef;
$self->{timeStamp} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columnParent}) {
      $self->{columnParent} = $vals->{columnParent};
    }
    if (defined $vals->{timeStamp}) {
      $self->{timeStamp} = $vals->{timeStamp};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_columns_since_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{columnParent});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I64) {
        $xfer += $input->readI64(\$self->{timeStamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_columns_since_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnParent}) {
    $xfer += $output->writeFieldBegin('columnParent', Net::Cassandra::Backend::TType::STRING, 3);
    $xfer += $output->writeString($self->{columnParent});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeStamp}) {
    $xfer += $output->writeFieldBegin('timeStamp', Net::Cassandra::Backend::TType::I64, 4);
    $xfer += $output->writeI64($self->{timeStamp});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_columns_since_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_columns_since_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ire} = undef;
$self->{nfe} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_columns_since_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size76 = 0;
          $self->{success} = [];
          my $_etype79 = 0;
          $xfer += $input->readListBegin(\$_etype79, \$_size76);
          for (my $_i80 = 0; $_i80 < $_size76; ++$_i80)
          {
            my $elem81 = undef;
            $elem81 = new Net::Cassandra::Backend::column_t();
            $xfer += $elem81->read($input);
            push(@{$self->{success}},$elem81);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{nfe} = new Net::Cassandra::Backend::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_columns_since_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::LIST, 0);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter82 (@{$self->{success}}) 
        {
          $xfer += ${iter82}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_slice_super_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_slice_super_args->mk_accessors( qw( tablename key columnFamily start finish isAscending offset count ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{tablename} = undef;
$self->{key} = undef;
$self->{columnFamily} = undef;
$self->{start} = undef;
$self->{finish} = undef;
$self->{isAscending} = undef;
$self->{offset} = undef;
$self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columnFamily}) {
      $self->{columnFamily} = $vals->{columnFamily};
    }
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{finish}) {
      $self->{finish} = $vals->{finish};
    }
    if (defined $vals->{isAscending}) {
      $self->{isAscending} = $vals->{isAscending};
    }
    if (defined $vals->{offset}) {
      $self->{offset} = $vals->{offset};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_slice_super_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{columnFamily});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{finish});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::BOOL) {
        $xfer += $input->readBool(\$self->{isAscending});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{offset});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_slice_super_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamily}) {
    $xfer += $output->writeFieldBegin('columnFamily', Net::Cassandra::Backend::TType::STRING, 3);
    $xfer += $output->writeString($self->{columnFamily});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', Net::Cassandra::Backend::TType::STRING, 4);
    $xfer += $output->writeString($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{finish}) {
    $xfer += $output->writeFieldBegin('finish', Net::Cassandra::Backend::TType::STRING, 5);
    $xfer += $output->writeString($self->{finish});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{isAscending}) {
    $xfer += $output->writeFieldBegin('isAscending', Net::Cassandra::Backend::TType::BOOL, 6);
    $xfer += $output->writeBool($self->{isAscending});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{offset}) {
    $xfer += $output->writeFieldBegin('offset', Net::Cassandra::Backend::TType::I32, 7);
    $xfer += $output->writeI32($self->{offset});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', Net::Cassandra::Backend::TType::I32, 8);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_slice_super_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_slice_super_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_slice_super_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size83 = 0;
          $self->{success} = [];
          my $_etype86 = 0;
          $xfer += $input->readListBegin(\$_etype86, \$_size83);
          for (my $_i87 = 0; $_i87 < $_size83; ++$_i87)
          {
            my $elem88 = undef;
            $elem88 = new Net::Cassandra::Backend::superColumn_t();
            $xfer += $elem88->read($input);
            push(@{$self->{success}},$elem88);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_slice_super_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::LIST, 0);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter89 (@{$self->{success}}) 
        {
          $xfer += ${iter89}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_slice_super_by_names_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_slice_super_by_names_args->mk_accessors( qw( tablename key columnFamily superColumnNames ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{tablename} = undef;
$self->{key} = undef;
$self->{columnFamily} = undef;
$self->{superColumnNames} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columnFamily}) {
      $self->{columnFamily} = $vals->{columnFamily};
    }
    if (defined $vals->{superColumnNames}) {
      $self->{superColumnNames} = $vals->{superColumnNames};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_slice_super_by_names_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{columnFamily});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size90 = 0;
          $self->{superColumnNames} = [];
          my $_etype93 = 0;
          $xfer += $input->readListBegin(\$_etype93, \$_size90);
          for (my $_i94 = 0; $_i94 < $_size90; ++$_i94)
          {
            my $elem95 = undef;
            $xfer += $input->readString(\$elem95);
            push(@{$self->{superColumnNames}},$elem95);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_slice_super_by_names_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamily}) {
    $xfer += $output->writeFieldBegin('columnFamily', Net::Cassandra::Backend::TType::STRING, 3);
    $xfer += $output->writeString($self->{columnFamily});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{superColumnNames}) {
    $xfer += $output->writeFieldBegin('superColumnNames', Net::Cassandra::Backend::TType::LIST, 4);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRING, scalar(@{$self->{superColumnNames}}));
      {
        foreach my $iter96 (@{$self->{superColumnNames}}) 
        {
          $xfer += $output->writeString($iter96);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_slice_super_by_names_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_slice_super_by_names_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_slice_super_by_names_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size97 = 0;
          $self->{success} = [];
          my $_etype100 = 0;
          $xfer += $input->readListBegin(\$_etype100, \$_size97);
          for (my $_i101 = 0; $_i101 < $_size97; ++$_i101)
          {
            my $elem102 = undef;
            $elem102 = new Net::Cassandra::Backend::superColumn_t();
            $xfer += $elem102->read($input);
            push(@{$self->{success}},$elem102);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_slice_super_by_names_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::LIST, 0);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter103 (@{$self->{success}}) 
        {
          $xfer += ${iter103}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_superColumn_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_superColumn_args->mk_accessors( qw( tablename key superColumnPath ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{tablename} = undef;
$self->{key} = undef;
$self->{superColumnPath} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{superColumnPath}) {
      $self->{superColumnPath} = $vals->{superColumnPath};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_superColumn_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{superColumnPath});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_superColumn_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{superColumnPath}) {
    $xfer += $output->writeFieldBegin('superColumnPath', Net::Cassandra::Backend::TType::STRING, 3);
    $xfer += $output->writeString($self->{superColumnPath});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_superColumn_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_superColumn_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ire} = undef;
$self->{nfe} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_superColumn_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{success} = new Net::Cassandra::Backend::superColumn_t();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{nfe} = new Net::Cassandra::Backend::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_superColumn_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_batch_insert_superColumn_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_batch_insert_superColumn_args->mk_accessors( qw( batchMutationSuper block_for ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{batchMutationSuper} = undef;
$self->{block_for} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{batchMutationSuper}) {
      $self->{batchMutationSuper} = $vals->{batchMutationSuper};
    }
    if (defined $vals->{block_for}) {
      $self->{block_for} = $vals->{block_for};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_batch_insert_superColumn_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{batchMutationSuper} = new Net::Cassandra::Backend::batch_mutation_super_t();
        $xfer += $self->{batchMutationSuper}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{block_for});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_batch_insert_superColumn_args');
  if (defined $self->{batchMutationSuper}) {
    $xfer += $output->writeFieldBegin('batchMutationSuper', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{batchMutationSuper}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{block_for}) {
    $xfer += $output->writeFieldBegin('block_for', Net::Cassandra::Backend::TType::I32, 2);
    $xfer += $output->writeI32($self->{block_for});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_batch_insert_superColumn_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_batch_insert_superColumn_result->mk_accessors( qw( ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{ire} = undef;
$self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_batch_insert_superColumn_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_batch_insert_superColumn_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_key_range_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_key_range_args->mk_accessors( qw( tablename columnFamily startWith stopAt maxResults ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{tablename} = undef;
$self->{columnFamily} = undef;
$self->{startWith} = "";
$self->{stopAt} = "";
$self->{maxResults} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{columnFamily}) {
      $self->{columnFamily} = $vals->{columnFamily};
    }
    if (defined $vals->{startWith}) {
      $self->{startWith} = $vals->{startWith};
    }
    if (defined $vals->{stopAt}) {
      $self->{stopAt} = $vals->{stopAt};
    }
    if (defined $vals->{maxResults}) {
      $self->{maxResults} = $vals->{maxResults};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_key_range_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{columnFamily});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{startWith});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{stopAt});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{maxResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_key_range_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamily}) {
    $xfer += $output->writeFieldBegin('columnFamily', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{columnFamily});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startWith}) {
    $xfer += $output->writeFieldBegin('startWith', Net::Cassandra::Backend::TType::STRING, 3);
    $xfer += $output->writeString($self->{startWith});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stopAt}) {
    $xfer += $output->writeFieldBegin('stopAt', Net::Cassandra::Backend::TType::STRING, 4);
    $xfer += $output->writeString($self->{stopAt});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxResults}) {
    $xfer += $output->writeFieldBegin('maxResults', Net::Cassandra::Backend::TType::I32, 5);
    $xfer += $output->writeI32($self->{maxResults});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_key_range_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_get_key_range_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_get_key_range_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size104 = 0;
          $self->{success} = [];
          my $_etype107 = 0;
          $xfer += $input->readListBegin(\$_etype107, \$_size104);
          for (my $_i108 = 0; $_i108 < $_size104; ++$_i108)
          {
            my $elem109 = undef;
            $xfer += $input->readString(\$elem109);
            push(@{$self->{success}},$elem109);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_get_key_range_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::LIST, 0);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter110 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter110);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_getStringProperty_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_getStringProperty_args->mk_accessors( qw( propertyName ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{propertyName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{propertyName}) {
      $self->{propertyName} = $vals->{propertyName};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_getStringProperty_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{propertyName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_getStringProperty_args');
  if (defined $self->{propertyName}) {
    $xfer += $output->writeFieldBegin('propertyName', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{propertyName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_getStringProperty_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_getStringProperty_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_getStringProperty_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_getStringProperty_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_getStringListProperty_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_getStringListProperty_args->mk_accessors( qw( propertyName ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{propertyName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{propertyName}) {
      $self->{propertyName} = $vals->{propertyName};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_getStringListProperty_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{propertyName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_getStringListProperty_args');
  if (defined $self->{propertyName}) {
    $xfer += $output->writeFieldBegin('propertyName', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{propertyName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_getStringListProperty_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_getStringListProperty_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_getStringListProperty_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size111 = 0;
          $self->{success} = [];
          my $_etype114 = 0;
          $xfer += $input->readListBegin(\$_etype114, \$_size111);
          for (my $_i115 = 0; $_i115 < $_size111; ++$_i115)
          {
            my $elem116 = undef;
            $xfer += $input->readString(\$elem116);
            push(@{$self->{success}},$elem116);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_getStringListProperty_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::LIST, 0);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter117 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter117);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_describeTable_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_describeTable_args->mk_accessors( qw( tableName ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_describeTable_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_describeTable_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_describeTable_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_describeTable_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{nfe} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_describeTable_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::MAP) {
        {
          my $_size118 = 0;
          $self->{success} = {};
          my $_ktype119 = 0;
          my $_vtype120 = 0;
          $xfer += $input->readMapBegin(\$_ktype119, \$_vtype120, \$_size118);
          for (my $_i122 = 0; $_i122 < $_size118; ++$_i122)
          {
            my $key123 = '';
            my $val124 = [];
            $xfer += $input->readString(\$key123);
            {
              my $_size125 = 0;
              $val124 = {};
              my $_ktype126 = 0;
              my $_vtype127 = 0;
              $xfer += $input->readMapBegin(\$_ktype126, \$_vtype127, \$_size125);
              for (my $_i129 = 0; $_i129 < $_size125; ++$_i129)
              {
                my $key130 = '';
                my $val131 = '';
                $xfer += $input->readString(\$key130);
                $xfer += $input->readString(\$val131);
                $val124->{$key130} = $val131;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{success}->{$key123} = $val124;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{nfe} = new Net::Cassandra::Backend::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_describeTable_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::MAP, 0);
    {
      $output->writeMapBegin(Net::Cassandra::Backend::TType::STRING, Net::Cassandra::Backend::TType::MAP, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter132,$viter133) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter132);
          {
            $output->writeMapBegin(Net::Cassandra::Backend::TType::STRING, Net::Cassandra::Backend::TType::STRING, scalar(keys %{${viter133}}));
            {
              while( my ($kiter134,$viter135) = each %{${viter133}}) 
              {
                $xfer += $output->writeString($kiter134);
                $xfer += $output->writeString($viter135);
              }
            }
            $output->writeMapEnd();
          }
        }
      }
      $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_executeQuery_args;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_executeQuery_args->mk_accessors( qw( query ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{query} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_executeQuery_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_executeQuery_args');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_executeQuery_result;
use Class::Accessor;
use base('Class::Accessor');
Net::Cassandra::Backend::Cassandra_executeQuery_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'Net::Cassandra::Backend::Cassandra_executeQuery_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{success} = new Net::Cassandra::Backend::CqlResult_t();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Net::Cassandra::Backend::Cassandra_executeQuery_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::CassandraIf;

sub get_slice_by_names{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnParent = shift;
  my $columnNames = shift;

  die 'implement interface';
}
sub get_slice{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnParent = shift;
  my $start = shift;
  my $finish = shift;
  my $isAscending = shift;
  my $offset = shift;
  my $count = shift;

  die 'implement interface';
}
sub get_column{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnPath = shift;

  die 'implement interface';
}
sub get_column_count{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnParent = shift;

  die 'implement interface';
}
sub insert{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnPath = shift;
  my $cellData = shift;
  my $timestamp = shift;
  my $block_for = shift;

  die 'implement interface';
}
sub batch_insert{
  my $self = shift;
  my $batchMutation = shift;
  my $block_for = shift;

  die 'implement interface';
}
sub remove{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnPathOrParent = shift;
  my $timestamp = shift;
  my $block_for = shift;

  die 'implement interface';
}
sub get_columns_since{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnParent = shift;
  my $timeStamp = shift;

  die 'implement interface';
}
sub get_slice_super{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnFamily = shift;
  my $start = shift;
  my $finish = shift;
  my $isAscending = shift;
  my $offset = shift;
  my $count = shift;

  die 'implement interface';
}
sub get_slice_super_by_names{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnFamily = shift;
  my $superColumnNames = shift;

  die 'implement interface';
}
sub get_superColumn{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $superColumnPath = shift;

  die 'implement interface';
}
sub batch_insert_superColumn{
  my $self = shift;
  my $batchMutationSuper = shift;
  my $block_for = shift;

  die 'implement interface';
}
sub get_key_range{
  my $self = shift;
  my $tablename = shift;
  my $columnFamily = shift;
  my $startWith = shift;
  my $stopAt = shift;
  my $maxResults = shift;

  die 'implement interface';
}
sub getStringProperty{
  my $self = shift;
  my $propertyName = shift;

  die 'implement interface';
}
sub getStringListProperty{
  my $self = shift;
  my $propertyName = shift;

  die 'implement interface';
}
sub describeTable{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}
sub executeQuery{
  my $self = shift;
  my $query = shift;

  die 'implement interface';
}
package Net::Cassandra::Backend::CassandraRest;

sub new {
  my $classname=shift;
  my $impl     =shift;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub get_slice_by_names{
  my $self = shift;
  my $request = shift;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $columnParent = ($request->{'columnParent'}) ? $request->{'columnParent'} : undef;
  my $columnNames = ($request->{'columnNames'}) ? $request->{'columnNames'} : undef;
  return $self->{impl}->get_slice_by_names($tablename, $key, $columnParent, $columnNames);
}

sub get_slice{
  my $self = shift;
  my $request = shift;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $columnParent = ($request->{'columnParent'}) ? $request->{'columnParent'} : undef;
  my $start = ($request->{'start'}) ? $request->{'start'} : undef;
  my $finish = ($request->{'finish'}) ? $request->{'finish'} : undef;
  my $isAscending = ($request->{'isAscending'}) ? $request->{'isAscending'} : undef;
  my $offset = ($request->{'offset'}) ? $request->{'offset'} : undef;
  my $count = ($request->{'count'}) ? $request->{'count'} : undef;
  return $self->{impl}->get_slice($tablename, $key, $columnParent, $start, $finish, $isAscending, $offset, $count);
}

sub get_column{
  my $self = shift;
  my $request = shift;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $columnPath = ($request->{'columnPath'}) ? $request->{'columnPath'} : undef;
  return $self->{impl}->get_column($tablename, $key, $columnPath);
}

sub get_column_count{
  my $self = shift;
  my $request = shift;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $columnParent = ($request->{'columnParent'}) ? $request->{'columnParent'} : undef;
  return $self->{impl}->get_column_count($tablename, $key, $columnParent);
}

sub insert{
  my $self = shift;
  my $request = shift;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $columnPath = ($request->{'columnPath'}) ? $request->{'columnPath'} : undef;
  my $cellData = ($request->{'cellData'}) ? $request->{'cellData'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $block_for = ($request->{'block_for'}) ? $request->{'block_for'} : undef;
  return $self->{impl}->insert($tablename, $key, $columnPath, $cellData, $timestamp, $block_for);
}

sub batch_insert{
  my $self = shift;
  my $request = shift;

  my $batchMutation = ($request->{'batchMutation'}) ? $request->{'batchMutation'} : undef;
  my $block_for = ($request->{'block_for'}) ? $request->{'block_for'} : undef;
  return $self->{impl}->batch_insert($batchMutation, $block_for);
}

sub remove{
  my $self = shift;
  my $request = shift;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $columnPathOrParent = ($request->{'columnPathOrParent'}) ? $request->{'columnPathOrParent'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $block_for = ($request->{'block_for'}) ? $request->{'block_for'} : undef;
  return $self->{impl}->remove($tablename, $key, $columnPathOrParent, $timestamp, $block_for);
}

sub get_columns_since{
  my $self = shift;
  my $request = shift;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $columnParent = ($request->{'columnParent'}) ? $request->{'columnParent'} : undef;
  my $timeStamp = ($request->{'timeStamp'}) ? $request->{'timeStamp'} : undef;
  return $self->{impl}->get_columns_since($tablename, $key, $columnParent, $timeStamp);
}

sub get_slice_super{
  my $self = shift;
  my $request = shift;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $columnFamily = ($request->{'columnFamily'}) ? $request->{'columnFamily'} : undef;
  my $start = ($request->{'start'}) ? $request->{'start'} : undef;
  my $finish = ($request->{'finish'}) ? $request->{'finish'} : undef;
  my $isAscending = ($request->{'isAscending'}) ? $request->{'isAscending'} : undef;
  my $offset = ($request->{'offset'}) ? $request->{'offset'} : undef;
  my $count = ($request->{'count'}) ? $request->{'count'} : undef;
  return $self->{impl}->get_slice_super($tablename, $key, $columnFamily, $start, $finish, $isAscending, $offset, $count);
}

sub get_slice_super_by_names{
  my $self = shift;
  my $request = shift;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $columnFamily = ($request->{'columnFamily'}) ? $request->{'columnFamily'} : undef;
  my $superColumnNames = ($request->{'superColumnNames'}) ? $request->{'superColumnNames'} : undef;
  return $self->{impl}->get_slice_super_by_names($tablename, $key, $columnFamily, $superColumnNames);
}

sub get_superColumn{
  my $self = shift;
  my $request = shift;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $superColumnPath = ($request->{'superColumnPath'}) ? $request->{'superColumnPath'} : undef;
  return $self->{impl}->get_superColumn($tablename, $key, $superColumnPath);
}

sub batch_insert_superColumn{
  my $self = shift;
  my $request = shift;

  my $batchMutationSuper = ($request->{'batchMutationSuper'}) ? $request->{'batchMutationSuper'} : undef;
  my $block_for = ($request->{'block_for'}) ? $request->{'block_for'} : undef;
  return $self->{impl}->batch_insert_superColumn($batchMutationSuper, $block_for);
}

sub get_key_range{
  my $self = shift;
  my $request = shift;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $columnFamily = ($request->{'columnFamily'}) ? $request->{'columnFamily'} : undef;
  my $startWith = ($request->{'startWith'}) ? $request->{'startWith'} : undef;
  my $stopAt = ($request->{'stopAt'}) ? $request->{'stopAt'} : undef;
  my $maxResults = ($request->{'maxResults'}) ? $request->{'maxResults'} : undef;
  return $self->{impl}->get_key_range($tablename, $columnFamily, $startWith, $stopAt, $maxResults);
}

sub getStringProperty{
  my $self = shift;
  my $request = shift;

  my $propertyName = ($request->{'propertyName'}) ? $request->{'propertyName'} : undef;
  return $self->{impl}->getStringProperty($propertyName);
}

sub getStringListProperty{
  my $self = shift;
  my $request = shift;

  my $propertyName = ($request->{'propertyName'}) ? $request->{'propertyName'} : undef;
  return $self->{impl}->getStringListProperty($propertyName);
}

sub describeTable{
  my $self = shift;
  my $request = shift;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->describeTable($tableName);
}

sub executeQuery{
  my $self = shift;
  my $request = shift;

  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  return $self->{impl}->executeQuery($query);
}

package Net::Cassandra::Backend::CassandraClient;

use base('Net::Cassandra::Backend::CassandraIf');
sub new {
  my $classname = shift;
  my $input     = shift;
  my $output    = shift;
  my $self      = {};
    $self->{input}  = $input;
    $self->{output} = defined $output ? $output : $input;
    $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub get_slice_by_names{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnParent = shift;
  my $columnNames = shift;

    $self->send_get_slice_by_names($tablename, $key, $columnParent, $columnNames);
  return $self->recv_get_slice_by_names();
}

sub send_get_slice_by_names{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnParent = shift;
  my $columnNames = shift;

  $self->{output}->writeMessageBegin('get_slice_by_names', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_slice_by_names_args();
  $args->{tablename} = $tablename;
  $args->{key} = $key;
  $args->{columnParent} = $columnParent;
  $args->{columnNames} = $columnNames;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_slice_by_names{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_slice_by_names_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  die "get_slice_by_names failed: unknown result";
}
sub get_slice{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnParent = shift;
  my $start = shift;
  my $finish = shift;
  my $isAscending = shift;
  my $offset = shift;
  my $count = shift;

    $self->send_get_slice($tablename, $key, $columnParent, $start, $finish, $isAscending, $offset, $count);
  return $self->recv_get_slice();
}

sub send_get_slice{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnParent = shift;
  my $start = shift;
  my $finish = shift;
  my $isAscending = shift;
  my $offset = shift;
  my $count = shift;

  $self->{output}->writeMessageBegin('get_slice', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_slice_args();
  $args->{tablename} = $tablename;
  $args->{key} = $key;
  $args->{columnParent} = $columnParent;
  $args->{start} = $start;
  $args->{finish} = $finish;
  $args->{isAscending} = $isAscending;
  $args->{offset} = $offset;
  $args->{count} = $count;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_slice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  die "get_slice failed: unknown result";
}
sub get_column{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnPath = shift;

    $self->send_get_column($tablename, $key, $columnPath);
  return $self->recv_get_column();
}

sub send_get_column{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnPath = shift;

  $self->{output}->writeMessageBegin('get_column', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_column_args();
  $args->{tablename} = $tablename;
  $args->{key} = $key;
  $args->{columnPath} = $columnPath;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_column{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_column_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  die "get_column failed: unknown result";
}
sub get_column_count{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnParent = shift;

    $self->send_get_column_count($tablename, $key, $columnParent);
  return $self->recv_get_column_count();
}

sub send_get_column_count{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnParent = shift;

  $self->{output}->writeMessageBegin('get_column_count', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_column_count_args();
  $args->{tablename} = $tablename;
  $args->{key} = $key;
  $args->{columnParent} = $columnParent;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_column_count{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_column_count_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "get_column_count failed: unknown result";
}
sub insert{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnPath = shift;
  my $cellData = shift;
  my $timestamp = shift;
  my $block_for = shift;

    $self->send_insert($tablename, $key, $columnPath, $cellData, $timestamp, $block_for);
  $self->recv_insert();
}

sub send_insert{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnPath = shift;
  my $cellData = shift;
  my $timestamp = shift;
  my $block_for = shift;

  $self->{output}->writeMessageBegin('insert', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_insert_args();
  $args->{tablename} = $tablename;
  $args->{key} = $key;
  $args->{columnPath} = $columnPath;
  $args->{cellData} = $cellData;
  $args->{timestamp} = $timestamp;
  $args->{block_for} = $block_for;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_insert{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_insert_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  return;
}
sub batch_insert{
  my $self = shift;
  my $batchMutation = shift;
  my $block_for = shift;

    $self->send_batch_insert($batchMutation, $block_for);
  $self->recv_batch_insert();
}

sub send_batch_insert{
  my $self = shift;
  my $batchMutation = shift;
  my $block_for = shift;

  $self->{output}->writeMessageBegin('batch_insert', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_batch_insert_args();
  $args->{batchMutation} = $batchMutation;
  $args->{block_for} = $block_for;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_batch_insert{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_batch_insert_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  return;
}
sub remove{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnPathOrParent = shift;
  my $timestamp = shift;
  my $block_for = shift;

    $self->send_remove($tablename, $key, $columnPathOrParent, $timestamp, $block_for);
  $self->recv_remove();
}

sub send_remove{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnPathOrParent = shift;
  my $timestamp = shift;
  my $block_for = shift;

  $self->{output}->writeMessageBegin('remove', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_remove_args();
  $args->{tablename} = $tablename;
  $args->{key} = $key;
  $args->{columnPathOrParent} = $columnPathOrParent;
  $args->{timestamp} = $timestamp;
  $args->{block_for} = $block_for;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_remove{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_remove_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  return;
}
sub get_columns_since{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnParent = shift;
  my $timeStamp = shift;

    $self->send_get_columns_since($tablename, $key, $columnParent, $timeStamp);
  return $self->recv_get_columns_since();
}

sub send_get_columns_since{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnParent = shift;
  my $timeStamp = shift;

  $self->{output}->writeMessageBegin('get_columns_since', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_columns_since_args();
  $args->{tablename} = $tablename;
  $args->{key} = $key;
  $args->{columnParent} = $columnParent;
  $args->{timeStamp} = $timeStamp;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_columns_since{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_columns_since_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  die "get_columns_since failed: unknown result";
}
sub get_slice_super{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnFamily = shift;
  my $start = shift;
  my $finish = shift;
  my $isAscending = shift;
  my $offset = shift;
  my $count = shift;

    $self->send_get_slice_super($tablename, $key, $columnFamily, $start, $finish, $isAscending, $offset, $count);
  return $self->recv_get_slice_super();
}

sub send_get_slice_super{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnFamily = shift;
  my $start = shift;
  my $finish = shift;
  my $isAscending = shift;
  my $offset = shift;
  my $count = shift;

  $self->{output}->writeMessageBegin('get_slice_super', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_slice_super_args();
  $args->{tablename} = $tablename;
  $args->{key} = $key;
  $args->{columnFamily} = $columnFamily;
  $args->{start} = $start;
  $args->{finish} = $finish;
  $args->{isAscending} = $isAscending;
  $args->{offset} = $offset;
  $args->{count} = $count;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_slice_super{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_slice_super_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "get_slice_super failed: unknown result";
}
sub get_slice_super_by_names{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnFamily = shift;
  my $superColumnNames = shift;

    $self->send_get_slice_super_by_names($tablename, $key, $columnFamily, $superColumnNames);
  return $self->recv_get_slice_super_by_names();
}

sub send_get_slice_super_by_names{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $columnFamily = shift;
  my $superColumnNames = shift;

  $self->{output}->writeMessageBegin('get_slice_super_by_names', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_slice_super_by_names_args();
  $args->{tablename} = $tablename;
  $args->{key} = $key;
  $args->{columnFamily} = $columnFamily;
  $args->{superColumnNames} = $superColumnNames;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_slice_super_by_names{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_slice_super_by_names_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "get_slice_super_by_names failed: unknown result";
}
sub get_superColumn{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $superColumnPath = shift;

    $self->send_get_superColumn($tablename, $key, $superColumnPath);
  return $self->recv_get_superColumn();
}

sub send_get_superColumn{
  my $self = shift;
  my $tablename = shift;
  my $key = shift;
  my $superColumnPath = shift;

  $self->{output}->writeMessageBegin('get_superColumn', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_superColumn_args();
  $args->{tablename} = $tablename;
  $args->{key} = $key;
  $args->{superColumnPath} = $superColumnPath;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_superColumn{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_superColumn_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  die "get_superColumn failed: unknown result";
}
sub batch_insert_superColumn{
  my $self = shift;
  my $batchMutationSuper = shift;
  my $block_for = shift;

    $self->send_batch_insert_superColumn($batchMutationSuper, $block_for);
  $self->recv_batch_insert_superColumn();
}

sub send_batch_insert_superColumn{
  my $self = shift;
  my $batchMutationSuper = shift;
  my $block_for = shift;

  $self->{output}->writeMessageBegin('batch_insert_superColumn', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_batch_insert_superColumn_args();
  $args->{batchMutationSuper} = $batchMutationSuper;
  $args->{block_for} = $block_for;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_batch_insert_superColumn{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_batch_insert_superColumn_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  return;
}
sub get_key_range{
  my $self = shift;
  my $tablename = shift;
  my $columnFamily = shift;
  my $startWith = shift;
  my $stopAt = shift;
  my $maxResults = shift;

    $self->send_get_key_range($tablename, $columnFamily, $startWith, $stopAt, $maxResults);
  return $self->recv_get_key_range();
}

sub send_get_key_range{
  my $self = shift;
  my $tablename = shift;
  my $columnFamily = shift;
  my $startWith = shift;
  my $stopAt = shift;
  my $maxResults = shift;

  $self->{output}->writeMessageBegin('get_key_range', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_key_range_args();
  $args->{tablename} = $tablename;
  $args->{columnFamily} = $columnFamily;
  $args->{startWith} = $startWith;
  $args->{stopAt} = $stopAt;
  $args->{maxResults} = $maxResults;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_key_range{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_key_range_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "get_key_range failed: unknown result";
}
sub getStringProperty{
  my $self = shift;
  my $propertyName = shift;

    $self->send_getStringProperty($propertyName);
  return $self->recv_getStringProperty();
}

sub send_getStringProperty{
  my $self = shift;
  my $propertyName = shift;

  $self->{output}->writeMessageBegin('getStringProperty', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_getStringProperty_args();
  $args->{propertyName} = $propertyName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getStringProperty{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_getStringProperty_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getStringProperty failed: unknown result";
}
sub getStringListProperty{
  my $self = shift;
  my $propertyName = shift;

    $self->send_getStringListProperty($propertyName);
  return $self->recv_getStringListProperty();
}

sub send_getStringListProperty{
  my $self = shift;
  my $propertyName = shift;

  $self->{output}->writeMessageBegin('getStringListProperty', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_getStringListProperty_args();
  $args->{propertyName} = $propertyName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getStringListProperty{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_getStringListProperty_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getStringListProperty failed: unknown result";
}
sub describeTable{
  my $self = shift;
  my $tableName = shift;

    $self->send_describeTable($tableName);
  return $self->recv_describeTable();
}

sub send_describeTable{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('describeTable', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_describeTable_args();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describeTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_describeTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  die "describeTable failed: unknown result";
}
sub executeQuery{
  my $self = shift;
  my $query = shift;

    $self->send_executeQuery($query);
  return $self->recv_executeQuery();
}

sub send_executeQuery{
  my $self = shift;
  my $query = shift;

  $self->{output}->writeMessageBegin('executeQuery', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_executeQuery_args();
  $args->{query} = $query;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_executeQuery{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_executeQuery_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "executeQuery failed: unknown result";
}
package Net::Cassandra::Backend::CassandraProcessor;

sub new {
    my $classname = shift;
    my $handler   = shift;
    my $self      = {};
    $self->{handler} = $handler;
    return bless($self,$classname);
}

sub process {
    my $self   = shift;
    my $input  = shift;
    my $output = shift;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!method_exists($self, $methodname)) {
      $input->skip(Net::Cassandra::Backend::TType::STRUCT);
      $input->readMessageEnd();
      my $x = new Net::Cassandra::Backend::TApplicationException('Function '.$fname.' not implemented.', Net::Cassandra::Backend::TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, Net::Cassandra::Backend::TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
  }

sub process_get_slice_by_names{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new Net::Cassandra::Backend::Cassandra_get_slice_by_names_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_get_slice_by_names_result();
    eval {
      $result->{success} = $self->{handler}->get_slice_by_names($args->tablename, $args->key, $args->columnParent, $args->columnNames);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::NotFoundException') ){ 
      $result->{nfe} = $@;
    }
    $output->writeMessageBegin('get_slice_by_names', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->getTransport()->flush();
}
sub process_get_slice{
  my $self = shift;
  my ($seqid, $input, $output); 
  my $args = new Net::Cassandra::Backend::Cassandra_get_slice_args();
  $args->read($input);
  $input->readMessageEnd();
  my $result = new Net::Cassandra::Backend::Cassandra_get_slice_result();
  eval {
    $result->{success} = $self->{handler}->get_slice($args->tablename, $args->key, $args->columnParent, $args->start, $args->finish, $args->isAscending, $args->offset, $args->count);
  }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::InvalidRequestException') ){ 
    $result->{ire} = $@;
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::NotFoundException') ){ 
    $result->{nfe} = $@;
  }
  $output->writeMessageBegin('get_slice', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
  $result->write($output);
  $output->getTransport()->flush();
}
sub process_get_column{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_get_column_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_get_column_result();
eval {
  $result->{success} = $self->{handler}->get_column($args->tablename, $args->key, $args->columnPath);
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::InvalidRequestException') ){ 
  $result->{ire} = $@;
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::NotFoundException') ){ 
  $result->{nfe} = $@;
}
$output->writeMessageBegin('get_column', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_get_column_count{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_get_column_count_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_get_column_count_result();
eval {
$result->{success} = $self->{handler}->get_column_count($args->tablename, $args->key, $args->columnParent);
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::InvalidRequestException') ){ 
$result->{ire} = $@;
}
$output->writeMessageBegin('get_column_count', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_insert{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_insert_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_insert_result();
eval {
$self->{handler}->insert($args->tablename, $args->key, $args->columnPath, $args->cellData, $args->timestamp, $args->block_for);
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::InvalidRequestException') ){ 
$result->{ire} = $@;
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::UnavailableException') ){ 
$result->{ue} = $@;
}
$output->writeMessageBegin('insert', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_batch_insert{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_batch_insert_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_batch_insert_result();
eval {
$self->{handler}->batch_insert($args->batchMutation, $args->block_for);
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::InvalidRequestException') ){ 
$result->{ire} = $@;
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::UnavailableException') ){ 
$result->{ue} = $@;
}
$output->writeMessageBegin('batch_insert', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_remove{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_remove_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_remove_result();
eval {
$self->{handler}->remove($args->tablename, $args->key, $args->columnPathOrParent, $args->timestamp, $args->block_for);
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::InvalidRequestException') ){ 
$result->{ire} = $@;
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::UnavailableException') ){ 
$result->{ue} = $@;
}
$output->writeMessageBegin('remove', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_get_columns_since{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_get_columns_since_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_get_columns_since_result();
eval {
$result->{success} = $self->{handler}->get_columns_since($args->tablename, $args->key, $args->columnParent, $args->timeStamp);
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::InvalidRequestException') ){ 
$result->{ire} = $@;
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::NotFoundException') ){ 
$result->{nfe} = $@;
}
$output->writeMessageBegin('get_columns_since', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_get_slice_super{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_get_slice_super_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_get_slice_super_result();
eval {
$result->{success} = $self->{handler}->get_slice_super($args->tablename, $args->key, $args->columnFamily, $args->start, $args->finish, $args->isAscending, $args->offset, $args->count);
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::InvalidRequestException') ){ 
$result->{ire} = $@;
}
$output->writeMessageBegin('get_slice_super', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_get_slice_super_by_names{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_get_slice_super_by_names_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_get_slice_super_by_names_result();
eval {
$result->{success} = $self->{handler}->get_slice_super_by_names($args->tablename, $args->key, $args->columnFamily, $args->superColumnNames);
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::InvalidRequestException') ){ 
$result->{ire} = $@;
}
$output->writeMessageBegin('get_slice_super_by_names', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_get_superColumn{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_get_superColumn_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_get_superColumn_result();
eval {
$result->{success} = $self->{handler}->get_superColumn($args->tablename, $args->key, $args->superColumnPath);
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::InvalidRequestException') ){ 
$result->{ire} = $@;
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::NotFoundException') ){ 
$result->{nfe} = $@;
}
$output->writeMessageBegin('get_superColumn', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_batch_insert_superColumn{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_batch_insert_superColumn_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_batch_insert_superColumn_result();
eval {
$self->{handler}->batch_insert_superColumn($args->batchMutationSuper, $args->block_for);
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::InvalidRequestException') ){ 
$result->{ire} = $@;
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::UnavailableException') ){ 
$result->{ue} = $@;
}
$output->writeMessageBegin('batch_insert_superColumn', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_get_key_range{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_get_key_range_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_get_key_range_result();
eval {
$result->{success} = $self->{handler}->get_key_range($args->tablename, $args->columnFamily, $args->startWith, $args->stopAt, $args->maxResults);
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::InvalidRequestException') ){ 
$result->{ire} = $@;
}
$output->writeMessageBegin('get_key_range', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_getStringProperty{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_getStringProperty_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_getStringProperty_result();
$result->{success} = $self->{handler}->getStringProperty($args->propertyName);
$output->writeMessageBegin('getStringProperty', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_getStringListProperty{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_getStringListProperty_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_getStringListProperty_result();
$result->{success} = $self->{handler}->getStringListProperty($args->propertyName);
$output->writeMessageBegin('getStringListProperty', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_describeTable{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_describeTable_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_describeTable_result();
eval {
$result->{success} = $self->{handler}->describeTable($args->tableName);
}; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::NotFoundException') ){ 
$result->{nfe} = $@;
}
$output->writeMessageBegin('describeTable', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_executeQuery{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Net::Cassandra::Backend::Cassandra_executeQuery_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Net::Cassandra::Backend::Cassandra_executeQuery_result();
$result->{success} = $self->{handler}->executeQuery($args->query);
$output->writeMessageBegin('executeQuery', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
1;
