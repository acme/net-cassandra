#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Net::Cassandra::Backend::Thrift;

use Net::Cassandra::Backend::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Net::Cassandra::Backend::Cassandra_get_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_args->mk_accessors( qw( keyspace key column_path consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{key} = undef;
  $self->{column_path} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_path} = new Net::Cassandra::Backend::ColumnPath();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{nfe} = undef;
  $self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{success} = new Net::Cassandra::Backend::ColumnOrSuperColumn();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{nfe} = new Net::Cassandra::Backend::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_slice_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_slice_args->mk_accessors( qw( keyspace key column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_parent} = new Net::Cassandra::Backend::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{predicate} = new Net::Cassandra::Backend::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_slice_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', Net::Cassandra::Backend::TType::STRUCT, 4);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 5);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_slice_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{nfe} = undef;
  $self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size14 = 0;
          $self->{success} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $elem19 = new Net::Cassandra::Backend::ColumnOrSuperColumn();
            $xfer += $elem19->read($input);
            push(@{$self->{success}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{nfe} = new Net::Cassandra::Backend::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::LIST, 0);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter20 (@{$self->{success}}) 
        {
          $xfer += ${iter20}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_multiget_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_multiget_args->mk_accessors( qw( keyspace keys column_path consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{keys} = undef;
  $self->{column_path} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{keys}) {
      $self->{keys} = $vals->{keys};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size21 = 0;
          $self->{keys} = [];
          my $_etype24 = 0;
          $xfer += $input->readListBegin(\$_etype24, \$_size21);
          for (my $_i25 = 0; $_i25 < $_size21; ++$_i25)
          {
            my $elem26 = undef;
            $xfer += $input->readString(\$elem26);
            push(@{$self->{keys}},$elem26);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_path} = new Net::Cassandra::Backend::ColumnPath();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{keys}) {
    $xfer += $output->writeFieldBegin('keys', Net::Cassandra::Backend::TType::LIST, 2);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRING, scalar(@{$self->{keys}}));
      {
        foreach my $iter27 (@{$self->{keys}}) 
        {
          $xfer += $output->writeString($iter27);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_multiget_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_multiget_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::MAP) {
        {
          my $_size28 = 0;
          $self->{success} = {};
          my $_ktype29 = 0;
          my $_vtype30 = 0;
          $xfer += $input->readMapBegin(\$_ktype29, \$_vtype30, \$_size28);
          for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
          {
            my $key33 = '';
            my $val34 = new Net::Cassandra::Backend::ColumnOrSuperColumn();
            $xfer += $input->readString(\$key33);
            $val34 = new Net::Cassandra::Backend::ColumnOrSuperColumn();
            $xfer += $val34->read($input);
            $self->{success}->{$key33} = $val34;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::MAP, 0);
    {
      $output->writeMapBegin(Net::Cassandra::Backend::TType::STRING, Net::Cassandra::Backend::TType::STRUCT, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter35,$viter36) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter35);
          $xfer += ${viter36}->write($output);
        }
      }
      $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_multiget_slice_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_multiget_slice_args->mk_accessors( qw( keyspace keys column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{keys} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{keys}) {
      $self->{keys} = $vals->{keys};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size37 = 0;
          $self->{keys} = [];
          my $_etype40 = 0;
          $xfer += $input->readListBegin(\$_etype40, \$_size37);
          for (my $_i41 = 0; $_i41 < $_size37; ++$_i41)
          {
            my $elem42 = undef;
            $xfer += $input->readString(\$elem42);
            push(@{$self->{keys}},$elem42);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_parent} = new Net::Cassandra::Backend::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{predicate} = new Net::Cassandra::Backend::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_slice_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{keys}) {
    $xfer += $output->writeFieldBegin('keys', Net::Cassandra::Backend::TType::LIST, 2);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRING, scalar(@{$self->{keys}}));
      {
        foreach my $iter43 (@{$self->{keys}}) 
        {
          $xfer += $output->writeString($iter43);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', Net::Cassandra::Backend::TType::STRUCT, 4);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 5);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_multiget_slice_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_multiget_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::MAP) {
        {
          my $_size44 = 0;
          $self->{success} = {};
          my $_ktype45 = 0;
          my $_vtype46 = 0;
          $xfer += $input->readMapBegin(\$_ktype45, \$_vtype46, \$_size44);
          for (my $_i48 = 0; $_i48 < $_size44; ++$_i48)
          {
            my $key49 = '';
            my $val50 = [];
            $xfer += $input->readString(\$key49);
            {
              my $_size51 = 0;
              $val50 = [];
              my $_etype54 = 0;
              $xfer += $input->readListBegin(\$_etype54, \$_size51);
              for (my $_i55 = 0; $_i55 < $_size51; ++$_i55)
              {
                my $elem56 = undef;
                $elem56 = new Net::Cassandra::Backend::ColumnOrSuperColumn();
                $xfer += $elem56->read($input);
                push(@{$val50},$elem56);
              }
              $xfer += $input->readListEnd();
            }
            $self->{success}->{$key49} = $val50;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::MAP, 0);
    {
      $output->writeMapBegin(Net::Cassandra::Backend::TType::STRING, Net::Cassandra::Backend::TType::LIST, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter57,$viter58) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter57);
          {
            $output->writeListBegin(Net::Cassandra::Backend::TType::STRUCT, scalar(@{${viter58}}));
            {
              foreach my $iter59 (@{${viter58}}) 
              {
                $xfer += ${iter59}->write($output);
              }
            }
            $output->writeListEnd();
          }
        }
      }
      $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_count_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_count_args->mk_accessors( qw( keyspace key column_parent consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_count_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_parent} = new Net::Cassandra::Backend::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_count_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_count_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_count_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_count_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_count_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_key_range_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_key_range_args->mk_accessors( qw( keyspace column_family start finish count consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{column_family} = undef;
  $self->{start} = "";
  $self->{finish} = "";
  $self->{count} = 100;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{finish}) {
      $self->{finish} = $vals->{finish};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_key_range_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{finish});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_key_range_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', Net::Cassandra::Backend::TType::STRING, 3);
    $xfer += $output->writeString($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{finish}) {
    $xfer += $output->writeFieldBegin('finish', Net::Cassandra::Backend::TType::STRING, 4);
    $xfer += $output->writeString($self->{finish});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', Net::Cassandra::Backend::TType::I32, 5);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 6);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_key_range_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_key_range_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_key_range_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size60 = 0;
          $self->{success} = [];
          my $_etype63 = 0;
          $xfer += $input->readListBegin(\$_etype63, \$_size60);
          for (my $_i64 = 0; $_i64 < $_size60; ++$_i64)
          {
            my $elem65 = undef;
            $xfer += $input->readString(\$elem65);
            push(@{$self->{success}},$elem65);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_key_range_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::LIST, 0);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter66 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter66);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_insert_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_insert_args->mk_accessors( qw( keyspace key column_path value timestamp consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{key} = undef;
  $self->{column_path} = undef;
  $self->{value} = undef;
  $self->{timestamp} = undef;
  $self->{consistency_level} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_insert_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_path} = new Net::Cassandra::Backend::ColumnPath();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_insert_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{column_path}->write($output);
#    $xfer += $output->writeString($self->{column_path});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', Net::Cassandra::Backend::TType::STRING, 4);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Net::Cassandra::Backend::TType::I64, 5);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 6);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_insert_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_insert_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_insert_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_insert_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_batch_insert_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_batch_insert_args->mk_accessors( qw( keyspace key cfmap consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{key} = undef;
  $self->{cfmap} = undef;
  $self->{consistency_level} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{cfmap}) {
      $self->{cfmap} = $vals->{cfmap};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_batch_insert_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::MAP) {
        {
          my $_size67 = 0;
          $self->{cfmap} = {};
          my $_ktype68 = 0;
          my $_vtype69 = 0;
          $xfer += $input->readMapBegin(\$_ktype68, \$_vtype69, \$_size67);
          for (my $_i71 = 0; $_i71 < $_size67; ++$_i71)
          {
            my $key72 = '';
            my $val73 = [];
            $xfer += $input->readString(\$key72);
            {
              my $_size74 = 0;
              $val73 = [];
              my $_etype77 = 0;
              $xfer += $input->readListBegin(\$_etype77, \$_size74);
              for (my $_i78 = 0; $_i78 < $_size74; ++$_i78)
              {
                my $elem79 = undef;
                $elem79 = new Net::Cassandra::Backend::ColumnOrSuperColumn();
                $xfer += $elem79->read($input);
                push(@{$val73},$elem79);
              }
              $xfer += $input->readListEnd();
            }
            $self->{cfmap}->{$key72} = $val73;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_batch_insert_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cfmap}) {
    $xfer += $output->writeFieldBegin('cfmap', Net::Cassandra::Backend::TType::MAP, 3);
    {
      $output->writeMapBegin(Net::Cassandra::Backend::TType::STRING, Net::Cassandra::Backend::TType::LIST, scalar(keys %{$self->{cfmap}}));
      {
        while( my ($kiter80,$viter81) = each %{$self->{cfmap}}) 
        {
          $xfer += $output->writeString($kiter80);
          {
            $output->writeListBegin(Net::Cassandra::Backend::TType::STRUCT, scalar(@{${viter81}}));
            {
              foreach my $iter82 (@{${viter81}}) 
              {
                $xfer += ${iter82}->write($output);
              }
            }
            $output->writeListEnd();
          }
        }
      }
      $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_batch_insert_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_batch_insert_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_batch_insert_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_batch_insert_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_remove_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_remove_args->mk_accessors( qw( keyspace key column_path timestamp consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{key} = undef;
  $self->{column_path} = undef;
  $self->{timestamp} = undef;
  $self->{consistency_level} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_path} = new Net::Cassandra::Backend::ColumnPath();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Net::Cassandra::Backend::TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 5);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_remove_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_remove_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_string_property_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_string_property_args->mk_accessors( qw( property ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{property} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{property}) {
      $self->{property} = $vals->{property};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_string_property_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{property});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_string_property_args');
  if (defined $self->{property}) {
    $xfer += $output->writeFieldBegin('property', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{property});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_string_property_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_string_property_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_string_property_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_string_property_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_string_list_property_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_string_list_property_args->mk_accessors( qw( property ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{property} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{property}) {
      $self->{property} = $vals->{property};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_string_list_property_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{property});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_string_list_property_args');
  if (defined $self->{property}) {
    $xfer += $output->writeFieldBegin('property', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{property});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_string_list_property_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_string_list_property_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_string_list_property_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size83 = 0;
          $self->{success} = [];
          my $_etype86 = 0;
          $xfer += $input->readListBegin(\$_etype86, \$_size83);
          for (my $_i87 = 0; $_i87 < $_size83; ++$_i87)
          {
            my $elem88 = undef;
            $xfer += $input->readString(\$elem88);
            push(@{$self->{success}},$elem88);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_string_list_property_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::LIST, 0);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter89 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter89);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_describe_keyspace_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_describe_keyspace_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspace_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_describe_keyspace_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_describe_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{nfe} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::MAP) {
        {
          my $_size90 = 0;
          $self->{success} = {};
          my $_ktype91 = 0;
          my $_vtype92 = 0;
          $xfer += $input->readMapBegin(\$_ktype91, \$_vtype92, \$_size90);
          for (my $_i94 = 0; $_i94 < $_size90; ++$_i94)
          {
            my $key95 = '';
            my $val96 = [];
            $xfer += $input->readString(\$key95);
            {
              my $_size97 = 0;
              $val96 = {};
              my $_ktype98 = 0;
              my $_vtype99 = 0;
              $xfer += $input->readMapBegin(\$_ktype98, \$_vtype99, \$_size97);
              for (my $_i101 = 0; $_i101 < $_size97; ++$_i101)
              {
                my $key102 = '';
                my $val103 = '';
                $xfer += $input->readString(\$key102);
                $xfer += $input->readString(\$val103);
                $val96->{$key102} = $val103;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{success}->{$key95} = $val96;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{nfe} = new Net::Cassandra::Backend::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::MAP, 0);
    {
      $output->writeMapBegin(Net::Cassandra::Backend::TType::STRING, Net::Cassandra::Backend::TType::MAP, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter104,$viter105) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter104);
          {
            $output->writeMapBegin(Net::Cassandra::Backend::TType::STRING, Net::Cassandra::Backend::TType::STRING, scalar(keys %{${viter105}}));
            {
              while( my ($kiter106,$viter107) = each %{${viter105}}) 
              {
                $xfer += $output->writeString($kiter106);
                $xfer += $output->writeString($viter107);
              }
            }
            $output->writeMapEnd();
          }
        }
      }
      $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::CassandraIf;

use strict;


sub get{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_slice{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub multiget{
  my $self = shift;
  my $keyspace = shift;
  my $keys = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub multiget_slice{
  my $self = shift;
  my $keyspace = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_count{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_parent = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_key_range{
  my $self = shift;
  my $keyspace = shift;
  my $column_family = shift;
  my $start = shift;
  my $finish = shift;
  my $count = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub insert{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $value = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub batch_insert{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $cfmap = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub remove{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_string_property{
  my $self = shift;
  my $property = shift;

  die 'implement interface';
}

sub get_string_list_property{
  my $self = shift;
  my $property = shift;

  die 'implement interface';
}

sub describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

package Net::Cassandra::Backend::CassandraRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub get{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get($keyspace, $key, $column_path, $consistency_level);
}

sub get_slice{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_slice($keyspace, $key, $column_parent, $predicate, $consistency_level);
}

sub multiget{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $keys = ($request->{'keys'}) ? $request->{'keys'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->multiget($keyspace, $keys, $column_path, $consistency_level);
}

sub multiget_slice{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $keys = ($request->{'keys'}) ? $request->{'keys'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->multiget_slice($keyspace, $keys, $column_parent, $predicate, $consistency_level);
}

sub get_count{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_count($keyspace, $key, $column_parent, $consistency_level);
}

sub get_key_range{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $column_family = ($request->{'column_family'}) ? $request->{'column_family'} : undef;
  my $start = ($request->{'start'}) ? $request->{'start'} : undef;
  my $finish = ($request->{'finish'}) ? $request->{'finish'} : undef;
  my $count = ($request->{'count'}) ? $request->{'count'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_key_range($keyspace, $column_family, $start, $finish, $count, $consistency_level);
}

sub insert{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->insert($keyspace, $key, $column_path, $value, $timestamp, $consistency_level);
}

sub batch_insert{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $cfmap = ($request->{'cfmap'}) ? $request->{'cfmap'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->batch_insert($keyspace, $key, $cfmap, $consistency_level);
}

sub remove{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->remove($keyspace, $key, $column_path, $timestamp, $consistency_level);
}

sub get_string_property{
  my ($self, $request) = @_;

  my $property = ($request->{'property'}) ? $request->{'property'} : undef;
  return $self->{impl}->get_string_property($property);
}

sub get_string_list_property{
  my ($self, $request) = @_;

  my $property = ($request->{'property'}) ? $request->{'property'} : undef;
  return $self->{impl}->get_string_list_property($property);
}

sub describe_keyspace{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->describe_keyspace($keyspace);
}

package Net::Cassandra::Backend::CassandraClient;


use base qw(Net::Cassandra::Backend::CassandraIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub get{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

    $self->send_get($keyspace, $key, $column_path, $consistency_level);
  return $self->recv_get();
}

sub send_get{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_args();
  $args->{keyspace} = $keyspace;
  $args->{key} = $key;
  $args->{column_path} = $column_path;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  die "get failed: unknown result";
}
sub get_slice{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_get_slice($keyspace, $key, $column_parent, $predicate, $consistency_level);
  return $self->recv_get_slice();
}

sub send_get_slice{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_slice', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_slice_args();
  $args->{keyspace} = $keyspace;
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_slice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  die "get_slice failed: unknown result";
}
sub multiget{
  my $self = shift;
  my $keyspace = shift;
  my $keys = shift;
  my $column_path = shift;
  my $consistency_level = shift;

    $self->send_multiget($keyspace, $keys, $column_path, $consistency_level);
  return $self->recv_multiget();
}

sub send_multiget{
  my $self = shift;
  my $keyspace = shift;
  my $keys = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('multiget', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_multiget_args();
  $args->{keyspace} = $keyspace;
  $args->{keys} = $keys;
  $args->{column_path} = $column_path;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_multiget{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_multiget_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  die "multiget failed: unknown result";
}
sub multiget_slice{
  my $self = shift;
  my $keyspace = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_multiget_slice($keyspace, $keys, $column_parent, $predicate, $consistency_level);
  return $self->recv_multiget_slice();
}

sub send_multiget_slice{
  my $self = shift;
  my $keyspace = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('multiget_slice', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_multiget_slice_args();
  $args->{keyspace} = $keyspace;
  $args->{keys} = $keys;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_multiget_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_multiget_slice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  die "multiget_slice failed: unknown result";
}
sub get_count{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_parent = shift;
  my $consistency_level = shift;

    $self->send_get_count($keyspace, $key, $column_parent, $consistency_level);
  return $self->recv_get_count();
}

sub send_get_count{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_parent = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_count', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_count_args();
  $args->{keyspace} = $keyspace;
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_count{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_count_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  die "get_count failed: unknown result";
}
sub get_key_range{
  my $self = shift;
  my $keyspace = shift;
  my $column_family = shift;
  my $start = shift;
  my $finish = shift;
  my $count = shift;
  my $consistency_level = shift;

    $self->send_get_key_range($keyspace, $column_family, $start, $finish, $count, $consistency_level);
  return $self->recv_get_key_range();
}

sub send_get_key_range{
  my $self = shift;
  my $keyspace = shift;
  my $column_family = shift;
  my $start = shift;
  my $finish = shift;
  my $count = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_key_range', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_key_range_args();
  $args->{keyspace} = $keyspace;
  $args->{column_family} = $column_family;
  $args->{start} = $start;
  $args->{finish} = $finish;
  $args->{count} = $count;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_key_range{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_key_range_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  die "get_key_range failed: unknown result";
}
sub insert{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $value = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

    $self->send_insert($keyspace, $key, $column_path, $value, $timestamp, $consistency_level);
  $self->recv_insert();
}

sub send_insert{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $value = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('insert', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_insert_args();
  $args->{keyspace} = $keyspace;
  $args->{key} = $key;
  $args->{column_path} = $column_path;
  $args->{value} = $value;
  $args->{timestamp} = $timestamp;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_insert{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_insert_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  return;
}
sub batch_insert{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $cfmap = shift;
  my $consistency_level = shift;

    $self->send_batch_insert($keyspace, $key, $cfmap, $consistency_level);
  $self->recv_batch_insert();
}

sub send_batch_insert{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $cfmap = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('batch_insert', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_batch_insert_args();
  $args->{keyspace} = $keyspace;
  $args->{key} = $key;
  $args->{cfmap} = $cfmap;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_batch_insert{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_batch_insert_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  return;
}
sub remove{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

    $self->send_remove($keyspace, $key, $column_path, $timestamp, $consistency_level);
  $self->recv_remove();
}

sub send_remove{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('remove', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_remove_args();
  $args->{keyspace} = $keyspace;
  $args->{key} = $key;
  $args->{column_path} = $column_path;
  $args->{timestamp} = $timestamp;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_remove{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_remove_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  return;
}
sub get_string_property{
  my $self = shift;
  my $property = shift;

    $self->send_get_string_property($property);
  return $self->recv_get_string_property();
}

sub send_get_string_property{
  my $self = shift;
  my $property = shift;

  $self->{output}->writeMessageBegin('get_string_property', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_string_property_args();
  $args->{property} = $property;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_string_property{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_string_property_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_string_property failed: unknown result";
}
sub get_string_list_property{
  my $self = shift;
  my $property = shift;

    $self->send_get_string_list_property($property);
  return $self->recv_get_string_list_property();
}

sub send_get_string_list_property{
  my $self = shift;
  my $property = shift;

  $self->{output}->writeMessageBegin('get_string_list_property', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_string_list_property_args();
  $args->{property} = $property;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_string_list_property{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_string_list_property_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_string_list_property failed: unknown result";
}
sub describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

    $self->send_describe_keyspace($keyspace);
  return $self->recv_describe_keyspace();
}

sub send_describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('describe_keyspace', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_describe_keyspace_args();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_describe_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  die "describe_keyspace failed: unknown result";
}
package Net::Cassandra::Backend::CassandraProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(Net::Cassandra::Backend::TType::STRUCT);
      $input->readMessageEnd();
      my $x = new Net::Cassandra::Backend::TApplicationException('Function '.$fname.' not implemented.', Net::Cassandra::Backend::TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, Net::Cassandra::Backend::TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_get {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_get_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_get_result();
    eval {
      $result->{success} = $self->{handler}->get($args->keyspace, $args->key, $args->column_path, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::NotFoundException') ){ 
      $result->{nfe} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
    }
    $output->writeMessageBegin('get', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_get_slice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_get_slice_result();
    eval {
      $result->{success} = $self->{handler}->get_slice($args->keyspace, $args->key, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::NotFoundException') ){ 
      $result->{nfe} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
    }
    $output->writeMessageBegin('get_slice', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_multiget {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_multiget_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_multiget_result();
    eval {
      $result->{success} = $self->{handler}->multiget($args->keyspace, $args->keys, $args->column_path, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
    }
    $output->writeMessageBegin('multiget', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_multiget_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_multiget_slice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_multiget_slice_result();
    eval {
      $result->{success} = $self->{handler}->multiget_slice($args->keyspace, $args->keys, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
    }
    $output->writeMessageBegin('multiget_slice', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_count {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_get_count_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_get_count_result();
    eval {
      $result->{success} = $self->{handler}->get_count($args->keyspace, $args->key, $args->column_parent, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
    }
    $output->writeMessageBegin('get_count', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_key_range {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_get_key_range_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_get_key_range_result();
    eval {
      $result->{success} = $self->{handler}->get_key_range($args->keyspace, $args->column_family, $args->start, $args->finish, $args->count, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
    }
    $output->writeMessageBegin('get_key_range', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_insert {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_insert_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_insert_result();
    eval {
      $self->{handler}->insert($args->keyspace, $args->key, $args->column_path, $args->value, $args->timestamp, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
    }
    $output->writeMessageBegin('insert', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_batch_insert {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_batch_insert_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_batch_insert_result();
    eval {
      $self->{handler}->batch_insert($args->keyspace, $args->key, $args->cfmap, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
    }
    $output->writeMessageBegin('batch_insert', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_remove {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_remove_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_remove_result();
    eval {
      $self->{handler}->remove($args->keyspace, $args->key, $args->column_path, $args->timestamp, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
    }
    $output->writeMessageBegin('remove', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_string_property {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_get_string_property_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_get_string_property_result();
    $result->{success} = $self->{handler}->get_string_property($args->property);
    $output->writeMessageBegin('get_string_property', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_string_list_property {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_get_string_list_property_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_get_string_list_property_result();
    $result->{success} = $self->{handler}->get_string_list_property($args->property);
    $output->writeMessageBegin('get_string_list_property', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_describe_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_describe_keyspace_result();
    eval {
      $result->{success} = $self->{handler}->describe_keyspace($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::NotFoundException') ){ 
      $result->{nfe} = $@;
    }
    $output->writeMessageBegin('describe_keyspace', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
