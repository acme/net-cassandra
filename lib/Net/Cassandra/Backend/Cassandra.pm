#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Net::Cassandra::Backend::Thrift;

use Net::Cassandra::Backend::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Net::Cassandra::Backend::Cassandra_get_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_args->mk_accessors( qw( keyspace key column_path consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{key} = undef;
  $self->{column_path} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_path} = new Net::Cassandra::Backend::ColumnPath();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{nfe} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{success} = new Net::Cassandra::Backend::ColumnOrSuperColumn();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{nfe} = new Net::Cassandra::Backend::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{te} = new Net::Cassandra::Backend::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Net::Cassandra::Backend::TType::STRUCT, 4);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_slice_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_slice_args->mk_accessors( qw( keyspace key column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_parent} = new Net::Cassandra::Backend::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{predicate} = new Net::Cassandra::Backend::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_slice_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', Net::Cassandra::Backend::TType::STRUCT, 4);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 5);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_slice_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size21 = 0;
          $self->{success} = [];
          my $_etype24 = 0;
          $xfer += $input->readListBegin(\$_etype24, \$_size21);
          for (my $_i25 = 0; $_i25 < $_size21; ++$_i25)
          {
            my $elem26 = undef;
            $elem26 = new Net::Cassandra::Backend::ColumnOrSuperColumn();
            $xfer += $elem26->read($input);
            push(@{$self->{success}},$elem26);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{te} = new Net::Cassandra::Backend::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::LIST, 0);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter27 (@{$self->{success}}) 
        {
          $xfer += ${iter27}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_multiget_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_multiget_args->mk_accessors( qw( keyspace keys column_path consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{keys} = undef;
  $self->{column_path} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{keys}) {
      $self->{keys} = $vals->{keys};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size28 = 0;
          $self->{keys} = [];
          my $_etype31 = 0;
          $xfer += $input->readListBegin(\$_etype31, \$_size28);
          for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
          {
            my $elem33 = undef;
            $xfer += $input->readString(\$elem33);
            push(@{$self->{keys}},$elem33);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_path} = new Net::Cassandra::Backend::ColumnPath();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{keys}) {
    $xfer += $output->writeFieldBegin('keys', Net::Cassandra::Backend::TType::LIST, 2);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRING, scalar(@{$self->{keys}}));
      {
        foreach my $iter34 (@{$self->{keys}}) 
        {
          $xfer += $output->writeString($iter34);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_multiget_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_multiget_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::MAP) {
        {
          my $_size35 = 0;
          $self->{success} = {};
          my $_ktype36 = 0;
          my $_vtype37 = 0;
          $xfer += $input->readMapBegin(\$_ktype36, \$_vtype37, \$_size35);
          for (my $_i39 = 0; $_i39 < $_size35; ++$_i39)
          {
            my $key40 = '';
            my $val41 = new Net::Cassandra::Backend::ColumnOrSuperColumn();
            $xfer += $input->readString(\$key40);
            $val41 = new Net::Cassandra::Backend::ColumnOrSuperColumn();
            $xfer += $val41->read($input);
            $self->{success}->{$key40} = $val41;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{te} = new Net::Cassandra::Backend::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::MAP, 0);
    {
      $output->writeMapBegin(Net::Cassandra::Backend::TType::STRING, Net::Cassandra::Backend::TType::STRUCT, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter42,$viter43) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter42);
          $xfer += ${viter43}->write($output);
        }
      }
      $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_multiget_slice_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_multiget_slice_args->mk_accessors( qw( keyspace keys column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{keys} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{keys}) {
      $self->{keys} = $vals->{keys};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size44 = 0;
          $self->{keys} = [];
          my $_etype47 = 0;
          $xfer += $input->readListBegin(\$_etype47, \$_size44);
          for (my $_i48 = 0; $_i48 < $_size44; ++$_i48)
          {
            my $elem49 = undef;
            $xfer += $input->readString(\$elem49);
            push(@{$self->{keys}},$elem49);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_parent} = new Net::Cassandra::Backend::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{predicate} = new Net::Cassandra::Backend::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_slice_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{keys}) {
    $xfer += $output->writeFieldBegin('keys', Net::Cassandra::Backend::TType::LIST, 2);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRING, scalar(@{$self->{keys}}));
      {
        foreach my $iter50 (@{$self->{keys}}) 
        {
          $xfer += $output->writeString($iter50);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', Net::Cassandra::Backend::TType::STRUCT, 4);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 5);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_multiget_slice_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_multiget_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::MAP) {
        {
          my $_size51 = 0;
          $self->{success} = {};
          my $_ktype52 = 0;
          my $_vtype53 = 0;
          $xfer += $input->readMapBegin(\$_ktype52, \$_vtype53, \$_size51);
          for (my $_i55 = 0; $_i55 < $_size51; ++$_i55)
          {
            my $key56 = '';
            my $val57 = [];
            $xfer += $input->readString(\$key56);
            {
              my $_size58 = 0;
              $val57 = [];
              my $_etype61 = 0;
              $xfer += $input->readListBegin(\$_etype61, \$_size58);
              for (my $_i62 = 0; $_i62 < $_size58; ++$_i62)
              {
                my $elem63 = undef;
                $elem63 = new Net::Cassandra::Backend::ColumnOrSuperColumn();
                $xfer += $elem63->read($input);
                push(@{$val57},$elem63);
              }
              $xfer += $input->readListEnd();
            }
            $self->{success}->{$key56} = $val57;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{te} = new Net::Cassandra::Backend::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::MAP, 0);
    {
      $output->writeMapBegin(Net::Cassandra::Backend::TType::STRING, Net::Cassandra::Backend::TType::LIST, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter64,$viter65) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter64);
          {
            $output->writeListBegin(Net::Cassandra::Backend::TType::STRUCT, scalar(@{${viter65}}));
            {
              foreach my $iter66 (@{${viter65}}) 
              {
                $xfer += ${iter66}->write($output);
              }
            }
            $output->writeListEnd();
          }
        }
      }
      $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_count_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_count_args->mk_accessors( qw( keyspace key column_parent consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_count_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_parent} = new Net::Cassandra::Backend::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_count_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_count_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_count_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_count_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{te} = new Net::Cassandra::Backend::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_count_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_key_range_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_key_range_args->mk_accessors( qw( keyspace column_family start finish count consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{column_family} = undef;
  $self->{start} = "";
  $self->{finish} = "";
  $self->{count} = 100;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{finish}) {
      $self->{finish} = $vals->{finish};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_key_range_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{finish});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_key_range_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', Net::Cassandra::Backend::TType::STRING, 3);
    $xfer += $output->writeString($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{finish}) {
    $xfer += $output->writeFieldBegin('finish', Net::Cassandra::Backend::TType::STRING, 4);
    $xfer += $output->writeString($self->{finish});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', Net::Cassandra::Backend::TType::I32, 5);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 6);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_key_range_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_key_range_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_key_range_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size67 = 0;
          $self->{success} = [];
          my $_etype70 = 0;
          $xfer += $input->readListBegin(\$_etype70, \$_size67);
          for (my $_i71 = 0; $_i71 < $_size67; ++$_i71)
          {
            my $elem72 = undef;
            $xfer += $input->readString(\$elem72);
            push(@{$self->{success}},$elem72);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{te} = new Net::Cassandra::Backend::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_key_range_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::LIST, 0);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter73 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter73);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_range_slice_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_range_slice_args->mk_accessors( qw( keyspace column_parent predicate start_key finish_key row_count consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{start_key} = "";
  $self->{finish_key} = "";
  $self->{row_count} = 100;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{start_key}) {
      $self->{start_key} = $vals->{start_key};
    }
    if (defined $vals->{finish_key}) {
      $self->{finish_key} = $vals->{finish_key};
    }
    if (defined $vals->{row_count}) {
      $self->{row_count} = $vals->{row_count};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_range_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_parent} = new Net::Cassandra::Backend::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{predicate} = new Net::Cassandra::Backend::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{start_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{finish_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{row_count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_range_slice_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_key}) {
    $xfer += $output->writeFieldBegin('start_key', Net::Cassandra::Backend::TType::STRING, 4);
    $xfer += $output->writeString($self->{start_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{finish_key}) {
    $xfer += $output->writeFieldBegin('finish_key', Net::Cassandra::Backend::TType::STRING, 5);
    $xfer += $output->writeString($self->{finish_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_count}) {
    $xfer += $output->writeFieldBegin('row_count', Net::Cassandra::Backend::TType::I32, 6);
    $xfer += $output->writeI32($self->{row_count});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 7);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_range_slice_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_range_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_range_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size74 = 0;
          $self->{success} = [];
          my $_etype77 = 0;
          $xfer += $input->readListBegin(\$_etype77, \$_size74);
          for (my $_i78 = 0; $_i78 < $_size74; ++$_i78)
          {
            my $elem79 = undef;
            $elem79 = new Net::Cassandra::Backend::KeySlice();
            $xfer += $elem79->read($input);
            push(@{$self->{success}},$elem79);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{te} = new Net::Cassandra::Backend::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_range_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::LIST, 0);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter80 (@{$self->{success}}) 
        {
          $xfer += ${iter80}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_insert_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_insert_args->mk_accessors( qw( keyspace key column_path value timestamp consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{key} = undef;
  $self->{column_path} = undef;
  $self->{value} = undef;
  $self->{timestamp} = undef;
  $self->{consistency_level} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_insert_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_path} = new Net::Cassandra::Backend::ColumnPath();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_insert_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', Net::Cassandra::Backend::TType::STRING, 4);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Net::Cassandra::Backend::TType::I64, 5);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 6);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_insert_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_insert_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_insert_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{te} = new Net::Cassandra::Backend::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_insert_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_batch_insert_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_batch_insert_args->mk_accessors( qw( keyspace key cfmap consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{key} = undef;
  $self->{cfmap} = undef;
  $self->{consistency_level} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{cfmap}) {
      $self->{cfmap} = $vals->{cfmap};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_batch_insert_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::MAP) {
        {
          my $_size81 = 0;
          $self->{cfmap} = {};
          my $_ktype82 = 0;
          my $_vtype83 = 0;
          $xfer += $input->readMapBegin(\$_ktype82, \$_vtype83, \$_size81);
          for (my $_i85 = 0; $_i85 < $_size81; ++$_i85)
          {
            my $key86 = '';
            my $val87 = [];
            $xfer += $input->readString(\$key86);
            {
              my $_size88 = 0;
              $val87 = [];
              my $_etype91 = 0;
              $xfer += $input->readListBegin(\$_etype91, \$_size88);
              for (my $_i92 = 0; $_i92 < $_size88; ++$_i92)
              {
                my $elem93 = undef;
                $elem93 = new Net::Cassandra::Backend::ColumnOrSuperColumn();
                $xfer += $elem93->read($input);
                push(@{$val87},$elem93);
              }
              $xfer += $input->readListEnd();
            }
            $self->{cfmap}->{$key86} = $val87;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_batch_insert_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cfmap}) {
    $xfer += $output->writeFieldBegin('cfmap', Net::Cassandra::Backend::TType::MAP, 3);
    {
      $output->writeMapBegin(Net::Cassandra::Backend::TType::STRING, Net::Cassandra::Backend::TType::LIST, scalar(keys %{$self->{cfmap}}));
      {
        while( my ($kiter94,$viter95) = each %{$self->{cfmap}}) 
        {
          $xfer += $output->writeString($kiter94);
          {
            $output->writeListBegin(Net::Cassandra::Backend::TType::STRUCT, scalar(@{${viter95}}));
            {
              foreach my $iter96 (@{${viter95}}) 
              {
                $xfer += ${iter96}->write($output);
              }
            }
            $output->writeListEnd();
          }
        }
      }
      $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_batch_insert_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_batch_insert_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_batch_insert_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{te} = new Net::Cassandra::Backend::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_batch_insert_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_remove_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_remove_args->mk_accessors( qw( keyspace key column_path timestamp consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{key} = undef;
  $self->{column_path} = undef;
  $self->{timestamp} = undef;
  $self->{consistency_level} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{column_path} = new Net::Cassandra::Backend::ColumnPath();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', Net::Cassandra::Backend::TType::STRING, 2);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Net::Cassandra::Backend::TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', Net::Cassandra::Backend::TType::I32, 5);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_remove_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_remove_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ire} = new Net::Cassandra::Backend::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{ue} = new Net::Cassandra::Backend::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{te} = new Net::Cassandra::Backend::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', Net::Cassandra::Backend::TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', Net::Cassandra::Backend::TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_string_property_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_string_property_args->mk_accessors( qw( property ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{property} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{property}) {
      $self->{property} = $vals->{property};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_string_property_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{property});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_string_property_args');
  if (defined $self->{property}) {
    $xfer += $output->writeFieldBegin('property', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{property});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_string_property_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_string_property_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_string_property_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_string_property_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_string_list_property_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_string_list_property_args->mk_accessors( qw( property ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{property} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{property}) {
      $self->{property} = $vals->{property};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_string_list_property_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{property});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_string_list_property_args');
  if (defined $self->{property}) {
    $xfer += $output->writeFieldBegin('property', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{property});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_get_string_list_property_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_get_string_list_property_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_string_list_property_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::LIST) {
        {
          my $_size97 = 0;
          $self->{success} = [];
          my $_etype100 = 0;
          $xfer += $input->readListBegin(\$_etype100, \$_size97);
          for (my $_i101 = 0; $_i101 < $_size97; ++$_i101)
          {
            my $elem102 = undef;
            $xfer += $input->readString(\$elem102);
            push(@{$self->{success}},$elem102);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_string_list_property_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::LIST, 0);
    {
      $output->writeListBegin(Net::Cassandra::Backend::TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter103 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter103);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_describe_keyspace_args;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_describe_keyspace_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspace_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', Net::Cassandra::Backend::TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::Cassandra_describe_keyspace_result;
use base qw(Class::Accessor);
Net::Cassandra::Backend::Cassandra_describe_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{nfe} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Net::Cassandra::Backend::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::MAP) {
        {
          my $_size104 = 0;
          $self->{success} = {};
          my $_ktype105 = 0;
          my $_vtype106 = 0;
          $xfer += $input->readMapBegin(\$_ktype105, \$_vtype106, \$_size104);
          for (my $_i108 = 0; $_i108 < $_size104; ++$_i108)
          {
            my $key109 = '';
            my $val110 = [];
            $xfer += $input->readString(\$key109);
            {
              my $_size111 = 0;
              $val110 = {};
              my $_ktype112 = 0;
              my $_vtype113 = 0;
              $xfer += $input->readMapBegin(\$_ktype112, \$_vtype113, \$_size111);
              for (my $_i115 = 0; $_i115 < $_size111; ++$_i115)
              {
                my $key116 = '';
                my $val117 = '';
                $xfer += $input->readString(\$key116);
                $xfer += $input->readString(\$val117);
                $val110->{$key116} = $val117;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{success}->{$key109} = $val110;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Net::Cassandra::Backend::TType::STRUCT) {
        $self->{nfe} = new Net::Cassandra::Backend::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Net::Cassandra::Backend::TType::MAP, 0);
    {
      $output->writeMapBegin(Net::Cassandra::Backend::TType::STRING, Net::Cassandra::Backend::TType::MAP, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter118,$viter119) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter118);
          {
            $output->writeMapBegin(Net::Cassandra::Backend::TType::STRING, Net::Cassandra::Backend::TType::STRING, scalar(keys %{${viter119}}));
            {
              while( my ($kiter120,$viter121) = each %{${viter119}}) 
              {
                $xfer += $output->writeString($kiter120);
                $xfer += $output->writeString($viter121);
              }
            }
            $output->writeMapEnd();
          }
        }
      }
      $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', Net::Cassandra::Backend::TType::STRUCT, 1);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Net::Cassandra::Backend::CassandraIf;

use strict;


sub get{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_slice{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub multiget{
  my $self = shift;
  my $keyspace = shift;
  my $keys = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub multiget_slice{
  my $self = shift;
  my $keyspace = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_count{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_parent = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_key_range{
  my $self = shift;
  my $keyspace = shift;
  my $column_family = shift;
  my $start = shift;
  my $finish = shift;
  my $count = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_range_slice{
  my $self = shift;
  my $keyspace = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $start_key = shift;
  my $finish_key = shift;
  my $row_count = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub insert{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $value = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub batch_insert{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $cfmap = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub remove{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_string_property{
  my $self = shift;
  my $property = shift;

  die 'implement interface';
}

sub get_string_list_property{
  my $self = shift;
  my $property = shift;

  die 'implement interface';
}

sub describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

package Net::Cassandra::Backend::CassandraRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub get{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get($keyspace, $key, $column_path, $consistency_level);
}

sub get_slice{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_slice($keyspace, $key, $column_parent, $predicate, $consistency_level);
}

sub multiget{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $keys = ($request->{'keys'}) ? $request->{'keys'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->multiget($keyspace, $keys, $column_path, $consistency_level);
}

sub multiget_slice{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $keys = ($request->{'keys'}) ? $request->{'keys'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->multiget_slice($keyspace, $keys, $column_parent, $predicate, $consistency_level);
}

sub get_count{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_count($keyspace, $key, $column_parent, $consistency_level);
}

sub get_key_range{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $column_family = ($request->{'column_family'}) ? $request->{'column_family'} : undef;
  my $start = ($request->{'start'}) ? $request->{'start'} : undef;
  my $finish = ($request->{'finish'}) ? $request->{'finish'} : undef;
  my $count = ($request->{'count'}) ? $request->{'count'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_key_range($keyspace, $column_family, $start, $finish, $count, $consistency_level);
}

sub get_range_slice{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $start_key = ($request->{'start_key'}) ? $request->{'start_key'} : undef;
  my $finish_key = ($request->{'finish_key'}) ? $request->{'finish_key'} : undef;
  my $row_count = ($request->{'row_count'}) ? $request->{'row_count'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_range_slice($keyspace, $column_parent, $predicate, $start_key, $finish_key, $row_count, $consistency_level);
}

sub insert{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->insert($keyspace, $key, $column_path, $value, $timestamp, $consistency_level);
}

sub batch_insert{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $cfmap = ($request->{'cfmap'}) ? $request->{'cfmap'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->batch_insert($keyspace, $key, $cfmap, $consistency_level);
}

sub remove{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->remove($keyspace, $key, $column_path, $timestamp, $consistency_level);
}

sub get_string_property{
  my ($self, $request) = @_;

  my $property = ($request->{'property'}) ? $request->{'property'} : undef;
  return $self->{impl}->get_string_property($property);
}

sub get_string_list_property{
  my ($self, $request) = @_;

  my $property = ($request->{'property'}) ? $request->{'property'} : undef;
  return $self->{impl}->get_string_list_property($property);
}

sub describe_keyspace{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->describe_keyspace($keyspace);
}

package Net::Cassandra::Backend::CassandraClient;


use base qw(Net::Cassandra::Backend::CassandraIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub get{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

    $self->send_get($keyspace, $key, $column_path, $consistency_level);
  return $self->recv_get();
}

sub send_get{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_args();
  $args->{keyspace} = $keyspace;
  $args->{key} = $key;
  $args->{column_path} = $column_path;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get failed: unknown result";
}
sub get_slice{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_get_slice($keyspace, $key, $column_parent, $predicate, $consistency_level);
  return $self->recv_get_slice();
}

sub send_get_slice{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_slice', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_slice_args();
  $args->{keyspace} = $keyspace;
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_slice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_slice failed: unknown result";
}
sub multiget{
  my $self = shift;
  my $keyspace = shift;
  my $keys = shift;
  my $column_path = shift;
  my $consistency_level = shift;

    $self->send_multiget($keyspace, $keys, $column_path, $consistency_level);
  return $self->recv_multiget();
}

sub send_multiget{
  my $self = shift;
  my $keyspace = shift;
  my $keys = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('multiget', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_multiget_args();
  $args->{keyspace} = $keyspace;
  $args->{keys} = $keys;
  $args->{column_path} = $column_path;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_multiget{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_multiget_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "multiget failed: unknown result";
}
sub multiget_slice{
  my $self = shift;
  my $keyspace = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_multiget_slice($keyspace, $keys, $column_parent, $predicate, $consistency_level);
  return $self->recv_multiget_slice();
}

sub send_multiget_slice{
  my $self = shift;
  my $keyspace = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('multiget_slice', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_multiget_slice_args();
  $args->{keyspace} = $keyspace;
  $args->{keys} = $keys;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_multiget_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_multiget_slice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "multiget_slice failed: unknown result";
}
sub get_count{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_parent = shift;
  my $consistency_level = shift;

    $self->send_get_count($keyspace, $key, $column_parent, $consistency_level);
  return $self->recv_get_count();
}

sub send_get_count{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_parent = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_count', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_count_args();
  $args->{keyspace} = $keyspace;
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_count{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_count_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_count failed: unknown result";
}
sub get_key_range{
  my $self = shift;
  my $keyspace = shift;
  my $column_family = shift;
  my $start = shift;
  my $finish = shift;
  my $count = shift;
  my $consistency_level = shift;

    $self->send_get_key_range($keyspace, $column_family, $start, $finish, $count, $consistency_level);
  return $self->recv_get_key_range();
}

sub send_get_key_range{
  my $self = shift;
  my $keyspace = shift;
  my $column_family = shift;
  my $start = shift;
  my $finish = shift;
  my $count = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_key_range', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_key_range_args();
  $args->{keyspace} = $keyspace;
  $args->{column_family} = $column_family;
  $args->{start} = $start;
  $args->{finish} = $finish;
  $args->{count} = $count;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_key_range{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_key_range_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_key_range failed: unknown result";
}
sub get_range_slice{
  my $self = shift;
  my $keyspace = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $start_key = shift;
  my $finish_key = shift;
  my $row_count = shift;
  my $consistency_level = shift;

    $self->send_get_range_slice($keyspace, $column_parent, $predicate, $start_key, $finish_key, $row_count, $consistency_level);
  return $self->recv_get_range_slice();
}

sub send_get_range_slice{
  my $self = shift;
  my $keyspace = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $start_key = shift;
  my $finish_key = shift;
  my $row_count = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_range_slice', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_range_slice_args();
  $args->{keyspace} = $keyspace;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{start_key} = $start_key;
  $args->{finish_key} = $finish_key;
  $args->{row_count} = $row_count;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_range_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_range_slice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_range_slice failed: unknown result";
}
sub insert{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $value = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

    $self->send_insert($keyspace, $key, $column_path, $value, $timestamp, $consistency_level);
  $self->recv_insert();
}

sub send_insert{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $value = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('insert', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_insert_args();
  $args->{keyspace} = $keyspace;
  $args->{key} = $key;
  $args->{column_path} = $column_path;
  $args->{value} = $value;
  $args->{timestamp} = $timestamp;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_insert{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_insert_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub batch_insert{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $cfmap = shift;
  my $consistency_level = shift;

    $self->send_batch_insert($keyspace, $key, $cfmap, $consistency_level);
  $self->recv_batch_insert();
}

sub send_batch_insert{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $cfmap = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('batch_insert', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_batch_insert_args();
  $args->{keyspace} = $keyspace;
  $args->{key} = $key;
  $args->{cfmap} = $cfmap;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_batch_insert{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_batch_insert_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub remove{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

    $self->send_remove($keyspace, $key, $column_path, $timestamp, $consistency_level);
  $self->recv_remove();
}

sub send_remove{
  my $self = shift;
  my $keyspace = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('remove', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_remove_args();
  $args->{keyspace} = $keyspace;
  $args->{key} = $key;
  $args->{column_path} = $column_path;
  $args->{timestamp} = $timestamp;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_remove{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_remove_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub get_string_property{
  my $self = shift;
  my $property = shift;

    $self->send_get_string_property($property);
  return $self->recv_get_string_property();
}

sub send_get_string_property{
  my $self = shift;
  my $property = shift;

  $self->{output}->writeMessageBegin('get_string_property', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_string_property_args();
  $args->{property} = $property;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_string_property{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_string_property_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_string_property failed: unknown result";
}
sub get_string_list_property{
  my $self = shift;
  my $property = shift;

    $self->send_get_string_list_property($property);
  return $self->recv_get_string_list_property();
}

sub send_get_string_list_property{
  my $self = shift;
  my $property = shift;

  $self->{output}->writeMessageBegin('get_string_list_property', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_get_string_list_property_args();
  $args->{property} = $property;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_string_list_property{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_get_string_list_property_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_string_list_property failed: unknown result";
}
sub describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

    $self->send_describe_keyspace($keyspace);
  return $self->recv_describe_keyspace();
}

sub send_describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('describe_keyspace', Net::Cassandra::Backend::TMessageType::CALL, $self->{seqid});
  my $args = new Net::Cassandra::Backend::Cassandra_describe_keyspace_args();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Net::Cassandra::Backend::TMessageType::EXCEPTION) {
    my $x = new Net::Cassandra::Backend::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Net::Cassandra::Backend::Cassandra_describe_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  die "describe_keyspace failed: unknown result";
}
package Net::Cassandra::Backend::CassandraProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(Net::Cassandra::Backend::TType::STRUCT);
      $input->readMessageEnd();
      my $x = new Net::Cassandra::Backend::TApplicationException('Function '.$fname.' not implemented.', Net::Cassandra::Backend::TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, Net::Cassandra::Backend::TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_get {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_get_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_get_result();
    eval {
      $result->{success} = $self->{handler}->get($args->keyspace, $args->key, $args->column_path, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::NotFoundException') ){ 
      $result->{nfe} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_get_slice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_get_slice_result();
    eval {
      $result->{success} = $self->{handler}->get_slice($args->keyspace, $args->key, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_slice', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_multiget {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_multiget_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_multiget_result();
    eval {
      $result->{success} = $self->{handler}->multiget($args->keyspace, $args->keys, $args->column_path, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('multiget', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_multiget_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_multiget_slice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_multiget_slice_result();
    eval {
      $result->{success} = $self->{handler}->multiget_slice($args->keyspace, $args->keys, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('multiget_slice', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_count {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_get_count_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_get_count_result();
    eval {
      $result->{success} = $self->{handler}->get_count($args->keyspace, $args->key, $args->column_parent, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_count', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_key_range {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_get_key_range_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_get_key_range_result();
    eval {
      $result->{success} = $self->{handler}->get_key_range($args->keyspace, $args->column_family, $args->start, $args->finish, $args->count, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_key_range', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_range_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_get_range_slice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_get_range_slice_result();
    eval {
      $result->{success} = $self->{handler}->get_range_slice($args->keyspace, $args->column_parent, $args->predicate, $args->start_key, $args->finish_key, $args->row_count, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_range_slice', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_insert {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_insert_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_insert_result();
    eval {
      $self->{handler}->insert($args->keyspace, $args->key, $args->column_path, $args->value, $args->timestamp, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('insert', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_batch_insert {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_batch_insert_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_batch_insert_result();
    eval {
      $self->{handler}->batch_insert($args->keyspace, $args->key, $args->cfmap, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('batch_insert', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_remove {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_remove_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_remove_result();
    eval {
      $self->{handler}->remove($args->keyspace, $args->key, $args->column_path, $args->timestamp, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('remove', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_string_property {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_get_string_property_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_get_string_property_result();
    $result->{success} = $self->{handler}->get_string_property($args->property);
    $output->writeMessageBegin('get_string_property', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_string_list_property {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_get_string_list_property_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_get_string_list_property_result();
    $result->{success} = $self->{handler}->get_string_list_property($args->property);
    $output->writeMessageBegin('get_string_list_property', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Net::Cassandra::Backend::Cassandra_describe_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Net::Cassandra::Backend::Cassandra_describe_keyspace_result();
    eval {
      $result->{success} = $self->{handler}->describe_keyspace($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Net::Cassandra::Backend::Cassandra::NotFoundException') ){ 
      $result->{nfe} = $@;
    }
    $output->writeMessageBegin('describe_keyspace', Net::Cassandra::Backend::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
